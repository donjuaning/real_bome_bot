"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrcaWhirlpoolClient = void 0;
const spl_token_1 = require("@solana/spl-token");
const decimal_js_1 = __importDefault(require("decimal.js"));
const token_price_1 = require("../utils/token-price");
const convert_data_1 = require("./convert-data");
const address_1 = require("../utils/address");
// Global rules for Decimals
//  - 40 digits of precision for the largest number
//  - 20 digits of precision for the smallest number
//  - Always round towards 0 to mirror smart contract rules
decimal_js_1.default.set({ precision: 40, toExpPos: 40, toExpNeg: -20, rounding: 1 });
class OrcaWhirlpoolClient {
    constructor(context) {
        this.ctx = context;
    }
    /**
     * Use on-chain dex data to derive usd prices for tokens.
     *
     * @param poolAddresses pools to be used for price discovery
     * @param baseTokenMint a token mint with known stable usd price (e.g. USDC)
     * @param baseTokenUSDPrice baseTokenMint's usd price. defaults to 1, assuming `baseTokenMint` is a USD stable coin
     * @param otherBaseTokenMints optional list of token mints to prioritize as base
     * @param refresh defaults to refreshing the cache
     */
    getTokenPrices(poolAddresses, baseTokenMint, baseTokenUSDPrice = new decimal_js_1.default(1), otherBaseTokenMints = [spl_token_1.NATIVE_MINT], refresh = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const allPools = yield this.ctx.accountFetcher.listPools(poolAddresses, refresh);
            const pools = allPools.filter((pool) => pool !== null);
            return (0, token_price_1.getTokenUSDPrices)(this.ctx.accountFetcher, pools, baseTokenMint, baseTokenUSDPrice, otherBaseTokenMints);
        });
    }
    /**
     * Fetch position data owned by the wallet address.
     *
     * @param walletAddress wallet address
     * @param refresh defaults to refreshing the cache
     * @returns positions owned by the wallet address
     */
    getUserPositions(walletAddress, refresh = true) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, convert_data_1.convertPositionDataToUserPositionData)(this.ctx, walletAddress, refresh);
        });
    }
    /**
     * Fetch list of pool data.
     *
     * @param poolAddresses list of pools to retrieve
     * @param refresh defaults to refreshing the cache
     * @returns list of pool data
     */
    getPools(poolAddresses, refresh = true) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, convert_data_1.convertWhirlpoolDataToPoolData)(this.ctx, poolAddresses, refresh);
        });
    }
    /**
     * Fetch pool data.
     *
     * @param poolAddress pool address
     * @param refresh defaults to refreshing the cache
     * @returns pool data
     */
    getPool(poolAddress, refresh = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const pool = (yield this.getPools([poolAddress], refresh))[(0, address_1.toPubKey)(poolAddress).toBase58()];
            return pool || null;
        });
    }
}
exports.OrcaWhirlpoolClient = OrcaWhirlpoolClient;
