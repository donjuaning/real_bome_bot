"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRemoveLiquidityQuote = void 0;
const whirlpool_client_sdk_1 = require("@orca-so/whirlpool-client-sdk");
const math_utils_1 = require("../../utils/web3/math-utils");
const position_util_1 = require("../../utils/public/position-util");
function getRemoveLiquidityQuote(param) {
    const positionStatus = position_util_1.PositionUtil.getPositionStatus(param.tickCurrentIndex, param.tickLowerIndex, param.tickUpperIndex);
    switch (positionStatus) {
        case position_util_1.PositionStatus.BelowRange:
            return getRemoveLiquidityQuoteWhenPositionIsBelowRange(param);
        case position_util_1.PositionStatus.InRange:
            return getRemoveLiquidityQuoteWhenPositionIsInRange(param);
        case position_util_1.PositionStatus.AboveRange:
            return getRemoveLiquidityQuoteWhenPositionIsAboveRange(param);
        default:
            throw new Error(`type ${positionStatus} is an unknown PositionStatus`);
    }
}
exports.getRemoveLiquidityQuote = getRemoveLiquidityQuote;
function getRemoveLiquidityQuoteWhenPositionIsBelowRange(param) {
    const { positionAddress, tickLowerIndex, tickUpperIndex, liquidity, slippageTolerance } = param;
    const sqrtPriceLowerX64 = (0, whirlpool_client_sdk_1.tickIndexToSqrtPriceX64)(tickLowerIndex);
    const sqrtPriceUpperX64 = (0, whirlpool_client_sdk_1.tickIndexToSqrtPriceX64)(tickUpperIndex);
    const estTokenA = (0, position_util_1.getTokenAFromLiquidity)(liquidity, sqrtPriceLowerX64, sqrtPriceUpperX64, false);
    const minTokenA = (0, position_util_1.adjustForSlippage)(estTokenA, slippageTolerance, false);
    return {
        positionAddress,
        minTokenA,
        minTokenB: math_utils_1.ZERO,
        estTokenA,
        estTokenB: math_utils_1.ZERO,
        liquidity,
    };
}
function getRemoveLiquidityQuoteWhenPositionIsInRange(param) {
    const { positionAddress, sqrtPrice, tickLowerIndex, tickUpperIndex, liquidity, slippageTolerance, } = param;
    const sqrtPriceX64 = sqrtPrice;
    const sqrtPriceLowerX64 = (0, whirlpool_client_sdk_1.tickIndexToSqrtPriceX64)(tickLowerIndex);
    const sqrtPriceUpperX64 = (0, whirlpool_client_sdk_1.tickIndexToSqrtPriceX64)(tickUpperIndex);
    const estTokenA = (0, position_util_1.getTokenAFromLiquidity)(liquidity, sqrtPriceX64, sqrtPriceUpperX64, false);
    const minTokenA = (0, position_util_1.adjustForSlippage)(estTokenA, slippageTolerance, false);
    const estTokenB = (0, position_util_1.getTokenBFromLiquidity)(liquidity, sqrtPriceLowerX64, sqrtPriceX64, false);
    const minTokenB = (0, position_util_1.adjustForSlippage)(estTokenB, slippageTolerance, false);
    return {
        positionAddress,
        minTokenA,
        minTokenB,
        estTokenA,
        estTokenB,
        liquidity,
    };
}
function getRemoveLiquidityQuoteWhenPositionIsAboveRange(param) {
    const { positionAddress, tickLowerIndex, tickUpperIndex, liquidity, slippageTolerance: slippageTolerance, } = param;
    const sqrtPriceLowerX64 = (0, whirlpool_client_sdk_1.tickIndexToSqrtPriceX64)(tickLowerIndex);
    const sqrtPriceUpperX64 = (0, whirlpool_client_sdk_1.tickIndexToSqrtPriceX64)(tickUpperIndex);
    const estTokenB = (0, position_util_1.getTokenBFromLiquidity)(liquidity, sqrtPriceLowerX64, sqrtPriceUpperX64, false);
    const minTokenB = (0, position_util_1.adjustForSlippage)(estTokenB, slippageTolerance, false);
    return {
        positionAddress,
        minTokenA: math_utils_1.ZERO,
        minTokenB,
        estTokenA: math_utils_1.ZERO,
        estTokenB,
        liquidity,
    };
}
