"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAddLiquidityQuote = void 0;
const position_util_1 = require("../../utils/public/position-util");
const whirlpool_client_sdk_1 = require("@orca-so/whirlpool-client-sdk");
const math_utils_1 = require("../../utils/web3/math-utils");
function getAddLiquidityQuote(param) {
    const positionStatus = position_util_1.PositionUtil.getPositionStatus(param.tickCurrentIndex, param.tickLowerIndex, param.tickUpperIndex);
    switch (positionStatus) {
        case position_util_1.PositionStatus.BelowRange:
            return getAddLiquidityQuoteWhenPositionIsBelowRange(param);
        case position_util_1.PositionStatus.InRange:
            return getAddLiquidityQuoteWhenPositionIsInRange(param);
        case position_util_1.PositionStatus.AboveRange:
            return getAddLiquidityQuoteWhenPositionIsAboveRange(param);
        default:
            throw new Error(`type ${positionStatus} is an unknown PositionStatus`);
    }
}
exports.getAddLiquidityQuote = getAddLiquidityQuote;
/*** Private ***/
function getAddLiquidityQuoteWhenPositionIsBelowRange(param) {
    const { tokenMintA, inputTokenMint, inputTokenAmount, tickLowerIndex, tickUpperIndex, slippageTolerance, } = param;
    if (!tokenMintA.equals(inputTokenMint)) {
        return {
            maxTokenA: math_utils_1.ZERO,
            maxTokenB: math_utils_1.ZERO,
            estTokenA: math_utils_1.ZERO,
            estTokenB: math_utils_1.ZERO,
            liquidity: math_utils_1.ZERO,
        };
    }
    const sqrtPriceLowerX64 = (0, whirlpool_client_sdk_1.tickIndexToSqrtPriceX64)(tickLowerIndex);
    const sqrtPriceUpperX64 = (0, whirlpool_client_sdk_1.tickIndexToSqrtPriceX64)(tickUpperIndex);
    const liquidity = (0, position_util_1.getLiquidityFromTokenA)(inputTokenAmount, sqrtPriceLowerX64, sqrtPriceUpperX64, false);
    const estTokenA = (0, position_util_1.getTokenAFromLiquidity)(liquidity, sqrtPriceLowerX64, sqrtPriceUpperX64, true);
    const maxTokenA = (0, position_util_1.adjustForSlippage)(estTokenA, slippageTolerance, true);
    return {
        maxTokenA,
        maxTokenB: math_utils_1.ZERO,
        estTokenA,
        estTokenB: math_utils_1.ZERO,
        liquidity,
    };
}
function getAddLiquidityQuoteWhenPositionIsInRange(param) {
    const { tokenMintA, sqrtPrice, inputTokenMint, inputTokenAmount, tickLowerIndex, tickUpperIndex, slippageTolerance, } = param;
    const sqrtPriceX64 = sqrtPrice;
    const sqrtPriceLowerX64 = (0, whirlpool_client_sdk_1.tickIndexToSqrtPriceX64)(tickLowerIndex);
    const sqrtPriceUpperX64 = (0, whirlpool_client_sdk_1.tickIndexToSqrtPriceX64)(tickUpperIndex);
    let [estTokenA, estTokenB] = tokenMintA.equals(inputTokenMint)
        ? [inputTokenAmount, undefined]
        : [undefined, inputTokenAmount];
    let liquidity;
    if (estTokenA) {
        liquidity = (0, position_util_1.getLiquidityFromTokenA)(estTokenA, sqrtPriceX64, sqrtPriceUpperX64, false);
        estTokenA = (0, position_util_1.getTokenAFromLiquidity)(liquidity, sqrtPriceX64, sqrtPriceUpperX64, true);
        estTokenB = (0, position_util_1.getTokenBFromLiquidity)(liquidity, sqrtPriceLowerX64, sqrtPriceX64, true);
    }
    else if (estTokenB) {
        liquidity = (0, position_util_1.getLiquidityFromTokenB)(estTokenB, sqrtPriceLowerX64, sqrtPriceX64, false);
        estTokenA = (0, position_util_1.getTokenAFromLiquidity)(liquidity, sqrtPriceX64, sqrtPriceUpperX64, true);
        estTokenB = (0, position_util_1.getTokenBFromLiquidity)(liquidity, sqrtPriceLowerX64, sqrtPriceX64, true);
    }
    else {
        throw new Error("invariant violation");
    }
    const maxTokenA = (0, position_util_1.adjustForSlippage)(estTokenA, slippageTolerance, true);
    const maxTokenB = (0, position_util_1.adjustForSlippage)(estTokenB, slippageTolerance, true);
    return {
        maxTokenA,
        maxTokenB,
        estTokenA,
        estTokenB,
        liquidity,
    };
}
function getAddLiquidityQuoteWhenPositionIsAboveRange(param) {
    const { tokenMintB, inputTokenMint, inputTokenAmount, tickLowerIndex, tickUpperIndex, slippageTolerance, } = param;
    if (!tokenMintB.equals(inputTokenMint)) {
        return {
            maxTokenA: math_utils_1.ZERO,
            maxTokenB: math_utils_1.ZERO,
            estTokenA: math_utils_1.ZERO,
            estTokenB: math_utils_1.ZERO,
            liquidity: math_utils_1.ZERO,
        };
    }
    const sqrtPriceLowerX64 = (0, whirlpool_client_sdk_1.tickIndexToSqrtPriceX64)(tickLowerIndex);
    const sqrtPriceUpperX64 = (0, whirlpool_client_sdk_1.tickIndexToSqrtPriceX64)(tickUpperIndex);
    const liquidity = (0, position_util_1.getLiquidityFromTokenB)(inputTokenAmount, sqrtPriceLowerX64, sqrtPriceUpperX64, false);
    const estTokenB = (0, position_util_1.getTokenBFromLiquidity)(liquidity, sqrtPriceLowerX64, sqrtPriceUpperX64, true);
    const maxTokenB = (0, position_util_1.adjustForSlippage)(estTokenB, slippageTolerance, true);
    return {
        maxTokenA: math_utils_1.ZERO,
        maxTokenB,
        estTokenA: math_utils_1.ZERO,
        estTokenB,
        liquidity,
    };
}
